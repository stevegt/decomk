# decomk

`decomk` is an isconf-inspired bootstrap wrapper for devcontainers.

It resolves a **context** (e.g., `owner/repo`, `repo`, `DEFAULT`) into:
- a list of **make targets** to run
- a list of `NAME=value` **tuples** to pass to `make`
- a generated env snapshot file for audit/debugging

It then runs **GNU make** as a subprocess in a persistent **stamp directory**,
so repeated runs converge quickly.

If you want background on isconf-style bootstraps, see https://infrastructures.org/.

## Status

This repo contains an MVP implementation in Go:
- `decomk plan`: resolve + print the plan; write env snapshot; does **not** run `make`
- `decomk run`: resolve + write env snapshot; run `make` in the stamp dir

Planned work lives under `TODO/`.

## Quick start (MVP)

1) Create `decomk.conf` and a `Makefile`.

For experimentation, you can put both in your workspace repo root:

`decomk.conf`:
```conf
# Context definitions (macros).
DEFAULT: Block00_base Block10_common FOO='bar baz'

# Repo-specific composition (context key).
myrepo: DEFAULT Block20_go
```

`Makefile`:
```make
SHELL := /bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# IMPORTANT: decomk runs make in the stamp directory.
# That means $@ is a file path under the stamp dir, and touching $@
# records "this target succeeded".

Block00_base:
	echo "base tools"
	touch $@

Block10_common: Block00_base
	echo "common tools (FOO=$(FOO))"
	touch $@

Block20_go: Block10_common
	echo "install go tools"
	touch $@
```

2) Run `plan`:
```bash
DECOMK_HOME=/tmp/decomk go run ./cmd/decomk plan -C .
```

3) Run `make` via `decomk`:
```bash
DECOMK_HOME=/tmp/decomk go run ./cmd/decomk run -C .
```

To install a binary instead of using `go run`:
```bash
go install ./cmd/decomk
```

## Worked example: 

Example container filesystem tree:  The container's workspace is
`/workspaces/repo1`, the config repo is cloned to
`/var/decomk/repos/decomk-config/`, and the decomk repo (this repo) is
cloned to /workspaces/decomk.

```text
/
├── var
│   └── decomk
│       └── stamps
│           ├── install-codex
│           ├── install-mob-consensus
│           └── install-neovim
└── workspaces
    ├── decoconf
    │   └── etc
    │       ├── decomk.conf
    │       └── Makefile
    ├── decomk
    │   └── cmd
    │       └── decomk
    │           └── main.go
    └── repo1

```

Example `/var/decomk/repos/decomk-config/decomk.conf`:
```conf
DEFAULT: Block00_base Block10_common

# Context key chosen via GITHUB_REPOSITORY when present.
stevegt/decomk: DEFAULT Block20_go
```

Example `/var/decomk/repos/decomk-config/Makefile`:
```make
SHELL := /bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

Block00_base:
	echo "base"
	touch $@

Block10_common: Block00_base
	echo "common"
	touch $@

Block20_go: Block10_common
	echo "go"
	touch $@
```

Run:
```bash
export DECOMK_HOME=/var/decomk
export GITHUB_REPOSITORY=stevegt/decomk
decomk plan -C .
decomk run -C .
```

After `decomk run`, stamp files exist under the printed `stampDir`, e.g.:
```text
/var/decomk/state/stamps/<workspaceKey>/<context>/
  Block00_base
  Block10_common
  Block20_go
```

The env snapshot is written to the printed `env` path, e.g.:
```sh
# generated by decomk; do not edit
export DECOMK_HOME='/var/decomk'
export DECOMK_CONTEXT='stevegt/decomk'
export DECOMK_STAMPDIR='/var/decomk/state/stamps/<workspaceKey>/<context>'
...
```

## Concepts

### Context

A **context key** selects a set of tokens from `decomk.conf`. Typical context
keys are:
- `DEFAULT` (common baseline)
- `owner/repo` (from Codespaces, via `GITHUB_REPOSITORY`)
- `repo` (fallback)

### Tokens

Each context key maps to a list of tokens. Tokens are one of:
- a macro reference (token matches another key in `decomk.conf`)
- a `NAME=value` tuple (passed to `make` on argv as a variable assignment)
- a make target name (everything else)

### Stamps

`decomk` runs `make` in a **stamp directory** outside the workspace repo.

Make targets should usually be **file targets** (not `.PHONY`), whose recipes
end by creating/updating `$@` (often via `touch $@`). Because `make` is run in
the stamp directory, `$@` becomes a persistent “stamp file” that records that
the step has succeeded.

## How `decomk` works (algorithm)

`decomk plan` and `decomk run` share the same resolution pipeline:

1) Determine `DECOMK_HOME`
   - flag: `-home`
   - env: `DECOMK_HOME`
   - default: `/var/decomk`

2) Determine `workspaceRoot`
   - `-C <dir>` selects the starting directory
   - if `<dir>` is in a git repo: `git rev-parse --show-toplevel`
   - otherwise: `abs(<dir>)`

3) Compute `workspaceKey`
   - a SHA-256 hash of `(GITHUB_REPOSITORY + "\n" + abs(workspaceRoot))`
   - used to namespace state per workspace

4) Load config definitions (`decomk.conf`)
   - **config repo** (optional): `<DECOMK_HOME>/repos/decomk-config/decomk.conf`
   - **repo-local overlay** (optional): `<workspaceRoot>/decomk.conf`
   - **explicit override** (optional): `-config <path>` or `DECOMK_CONFIG`

   Precedence is “last wins”:
   - config repo (lowest)
   - repo-local
   - explicit `-config` / `DECOMK_CONFIG` (highest)

   Each of those sources is loaded as a *tree*:
   - the base `decomk.conf`
   - plus optional `decomk.d/*.conf` in lexical order
     - later files override earlier ones by key

5) Choose `contextKey`
   - `-context <key>` (must exist in config)
   - `DECOMK_CONTEXT` (must exist in config)
   - `GITHUB_REPOSITORY` (`owner/repo`), then just `repo`
   - `DEFAULT`

6) Seed tokens
   - common composition is `DEFAULT + contextKey`
   - if a context explicitly includes `DEFAULT` in its own token list, decomk
     does not add `DEFAULT` implicitly (avoids duplicates)

7) Expand macros (recursive)
   - if a token exactly matches a key in the config map, it is replaced by that
     key’s token list, recursively
   - unknown tokens remain literal
   - guardrails:
     - cycle detection
     - maximum depth (default 64; override with `-max-expand-depth`)

8) Partition expanded tokens
   - tuples: `NAME=value` where `NAME` matches `[A-Za-z_][A-Za-z0-9_]*`
   - targets: all other tokens

9) Compute state paths
   - context keys are sanitized into a single safe path component (and include a
     short hash suffix) for use in directory names
   - stamp dir:
     - `<DECOMK_HOME>/state/stamps/<workspaceKey>/<context>/`
   - env snapshot:
     - `<DECOMK_HOME>/state/env/<workspaceKey>/<context>.sh`

10) Write the env snapshot (`plan` and `run`)
    - a shell-friendly file with `export NAME='value'` lines
    - includes:
      - computed `DECOMK_*` exports
      - config-provided tuples

11) Execute make (`run` only)
    - determine `Makefile` path:
      - `-makefile <path>` if set
      - otherwise, first existing of:
        - `<DECOMK_HOME>/repos/decomk-config/Makefile`
        - `dirname(-config)/Makefile` (if `-config`/`DECOMK_CONFIG` is set)
        - `<workspaceRoot>/Makefile`
    - acquire an exclusive per-workspace lock:
      - `<DECOMK_HOME>/state/locks/<workspaceKey>.lock`
    - ensure stamp dir exists
    - **touch existing stamps** in the stamp dir (see below)
    - create a per-run audit dir:
      - `<DECOMK_HOME>/state/audit/<workspaceKey>/<runID>/`
      - `runID` includes sub-second time + pid for uniqueness
    - run:
      - `make -f <Makefile> <tuples...> <targets...>`
      - working directory = stamp dir
      - stdout/stderr are teed to `make.log` under the audit dir

## `decomk.conf` format

`decomk.conf` is intentionally small and deterministic:

- Whole-line comments start with `#`.
- Key lines are `key: token token token`.
  - The `:` must be followed by whitespace or end-of-line (this avoids treating
    `http://...` as a key line).
  - Keys cannot contain `=`.
- Any other non-empty, non-comment line is a continuation line and appends more
  tokens to the previous key.
- Tokens are whitespace-separated.
  - Single quotes may be used to include spaces inside a token:
    - `FOO='bar baz'` parses as one token `FOO=bar baz`
  - Backslash escapes the next rune when not in single quotes.

## Makefile expectations and example

`decomk` runs `make` in the stamp directory and passes:
- tuples as argv variable assignments (`NAME=value`)
- targets as argv targets

This is the key idea: your “units of work” should be *make file targets* whose
recipes end by touching `$@`.

Example:
```make
SHELL := /bin/bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# In decomk's execution model, targets below are files created in the stamp dir.

Block00_base:
	echo "base"
	touch $@

Block10_common: Block00_base
	echo "common"
	touch $@
```

Recommendation: touch `$@` *last* and only on success.

## Stamps and invalidation

### Why “touch existing stamps”?

Provisioning/bootstrapping often wants semantics closer to:
“run once unless explicitly invalidated”
than:
“re-run when a prerequisite timestamp changes”.

So before running `make`, `decomk` updates the mtime of existing (non-hidden)
regular files in the stamp dir, effectively making stamp deletion the main way
to force re-execution.

### How to force a step to re-run

Delete its stamp file in the stamp directory, then run again:
```bash
rm -f "$DECOMK_HOME/state/stamps/<workspaceKey>/<context>/Block20_go"
decomk run ...
```

For “rerun everything”, delete the whole context stamp directory (a future
`decomk clean` command will automate this).

## Persistent directory layout

By default, state lives under `/var/decomk`. You can override it with
`DECOMK_HOME` or `decomk -home`.

Current layout (MVP):
```text
<DECOMK_HOME>/
  repos/
    decomk-config/
      decomk.conf
      decomk.d/*.conf        (optional)
      Makefile              (recommended default)
  state/
    env/<workspaceKey>/<context>.sh
    stamps/<workspaceKey>/<context>/
      Block00_base          (stamp files created by make)
      Block10_common
      ...
    audit/<workspaceKey>/<runID>/make.log
    locks/<workspaceKey>.lock
```

## CLI usage

```text
decomk plan [flags]
decomk run  [flags]

Flags:
  -home <abs-path>          Override DECOMK_HOME
  -C <dir>                  Workspace directory (like make -C)
  -context <key>            Override context selection
  -config <path>            Explicit config file (overrides defaults)
  -makefile <path>          Explicit Makefile path
  -max-expand-depth <n>     Macro expansion depth limit (default 64)
  -v                        Reserved for future verbose output
```

## Devcontainer notes

- `/var/decomk` must be writable by the dev user.
  - In a Dockerfile, you typically want:
    - `RUN mkdir -p /var/decomk && chown -R $USER:$USER /var/decomk`
- The repo’s workspace path is host-dependent; prefer using
  `${containerWorkspaceFolder}` in `devcontainer.json` rather than assuming
  `/workspaces/<repo>`.

## Limitations (current MVP)

- No automatic cloning/pulling of the config repo yet. For now, either:
  - pass `-config /path/to/decomk.conf`, or
  - create `decomk.conf` (and optionally `Makefile`) in the workspace, or
  - manually populate `<DECOMK_HOME>/repos/decomk-config/`.
- No `status` / `clean` commands yet.
- Config parser is intentionally minimal (single quotes only; whole-line comments only).
